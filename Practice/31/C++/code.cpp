#include <iostream>
#include <vector>
#include <fstream>

std::ostream& operator<< (std::ostream& stream, std::vector<int>& vec) {
	stream << vec.size() << "\t|";
	for (auto& elem : vec) {
		stream << ' ' << &elem;
	}
	return stream;
}

int main() {
	std::vector<int> vec;
	std::ofstream file("data.txt");

	/* Часть I
	   Вопрос 1.
	   Адреса первых элементов всегда разные, потому что при вызове оператора <<
	   весь вектор копируется в новую память
	   Адрес следующего элемента это адрес предыдущего + sizeof(int),
	   то есть все элементы распологаются сразу друг за другом */
	
	/* Вопрос 2
	   Если запомнить адрес первого элемнента при длине 15 и попытаться его изменить
	   при длине 25, то 99.999999% шанс того, что первый элемент не изменится,
	   потому что весь массив был перемещён в новую память (читать далее в части III)
	   + место в памяти, когда вектор был 15 элементов
	   может быть слишком маленьким для вектора 25 элементов,
	   поэтому массив там не разместится

	   offtop | В языке Rust эта махинация запрещена, потому что вектор при его изменении
		      | может быть перемещён и адрес будет ссылаться на старое место. */
	for (int i = 0; i < 64; ++i) {
		vec.push_back(0);
		file << vec << "\n";
	}
	file << "\n";

	/* Part II
	   Вопрос 3.
	   Смотри ответ в вопросе 1 */
	while (!vec.empty()) {
		vec.pop_back();
		file << vec << "\n";
	}

	// Part III
	/* Вопрос 4
	   Если оператор << принимает по значению, тогда вектор не копируется при вызове функции
	   Изменения с предыдущим выводом есть. Когда из вектора начинают убирать элементы,
	   адрес первого элемента остаётся одним и тем же.
	   При добавлении элементов адреса элементов всё так же псевдо случайны.
	   
	   Вектор использует аллокацию памяти в куче. Для этой аллокации нужно знать размер аллоцируемых байт.
	   
	   Количество аллоцированных байт является ёмкость вектора (capacity)
	   Причём, ёмкость != длина. Длина всегда будет меньше или равно ёмкости.
	   Получается, если длина меньше ёмкости, тогда некоторое аллоцированное место просто не используется
	
	   Вектор аллоцирует в памяти место для всех элементов.
	   Если в вектор добавить элемент, и длина вектора равна ёмкости,
	   Вектор аллоцирует новую память, с ёмкостью на sizeof(int) байт больше,
	   а потом копирует все элементы из предыдущей памяти в новую
	   и делает delete старой памяти.
	
	   В случае pop_back из вектора, аллоцировать новую память нет необходимости,
	   просто уменьшается длина вектора, ёмкость остаётся преждней
	   Именно поэтому адрес первого элемента остаётся одним и тем же */
	
}
